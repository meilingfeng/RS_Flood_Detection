```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA)
```

# Load packages
```{r}
packages <- c('terra','tidyverse','sf','viridis','patchwork')
invisible(lapply(packages, library, character.only = TRUE))
library("rje") #expit, logit transformations
```

# Set directories
```{r}
outDir<-"D:/Flood_Index/Data/Outputs/"
inDir<-"D:/Flood_Index/Data/Inputs/"
```

# Quality Filtering

Now we should do additional quality filtering.

Unpack the FMask bits to remove all pixels that are cloud, cloud shadow, cloud dilation, or have high aerosol levels. HLS quality information can be found in section 6.5 of the [HLS V2.0 User Guide](https://lpdaac.usgs.gov/documents/1118/HLS_User_Guide_V2.pdf).

```{r, warning=FALSE}
#read in nest - band data
nests_all_bands<-do.call('rbind',
                         map(list.files(path=outDir, pattern = "^CT_nests_all_HLS_bands_row",full.names = T),
                             read.csv)) 

nests_all_bands_clear<-nests_all_bands%>%
  rowwise()%>%
         # Unpack the bit coded QA information
  mutate(bit_str = paste(as.integer(intToBits(FMask)), collapse=""),
         # flag pixels that are clouds, cloud dilation, or cloud shadow
         cloud_shadow=ifelse(substr(bit_str, 2, 2) == '1'|substr(bit_str, 3, 3) == '1'|substr(bit_str, 4, 4) == '1',1,0),
         # exclude clear pixels with high aerosol levels (bit code "11")
         clear=ifelse(substr(bit_str, 7, 8) == '01'|substr(bit_str, 7, 8) == '00'|substr(bit_str, 7, 8) == '10',1,0), 
         # flag pixels that are water
         water=ifelse(substr(bit_str, 6, 6) == '1',1,0))%>%
      #remove cloud/dilation, cloud shadow, and high aerosol pixels
  ungroup()%>%
  filter(cloud_shadow==0&clear==1)


#write.csv(nests_all_bands_clear,paste0(outDir,"CT_nests_all_HLS_bands_clear.csv"),row.names=F)
```


# Transform the spectral bands into flooding indicators

We just identified which pixels the CFmask algorithm classified as water. This will be one flooding indicator.

Now we will calculate three other possible water indicators. FLATS is specifically calibrated to mid-Atlantic tidal marsh habitat and accounts for phenological changes in marsh vegetation to distinguish inundation changes in vegetated areas (Narron et al., 2022). However, it was derived from a generalized linear model trained on flooding data from a single marsh site in Georgia, so the model coefficients may not apply consistently to  vegetation and geologic composition in marshes throughout the breeding range. FLATS uses a normalized difference water index (NDWI) based on the red and first SWIR bands in Landsat 8. We will also test NDWI derived by McFeeters, 1996 which has since been modified (Xu 2005) to enhance open water features using the relative difference between the green and SWIR bands to distinguish the high absorption of the SWIR bands by water. The last flooding indicator we will test is tasseled-cap wetness, which compresses multispectral data into a single band that describes physical characteristics best associated with higher water content. Tasseled-cap wetness is sensor specific and the band coefficients have been updated to fit the Landsat-8 OLI sensor (Baig et al., 2014). We will use coefficients used for Landsat 8 because HLS adjusts the bandpass widths of Sentinel-2 to align with the OLI sensor (Claverie et al., 2018). 

```{r}
# we have already identified wet pixels via CFMask

#Now calculate FLATS, TC Wetness, as well as the NDWI and Phenology indices used to create FLATS
nests_all_bands_clear<-nests_all_bands_clear%>%
  mutate(pheno=(Green-Red)/(Green+Red),
         NDWI=(Red-SWIR1)/(Red+SWIR1),
         FLATS=expit(-1.6+20*NDWI+68.6*pheno),
         NDWI=(Green-SWIR1)/(Green+SWIR1),
         TCWet=(0.1509*Blue)+(0.1973*Green)+(0.3283*Red)+(0.3407*NIR)-(0.7117*SWIR1)-(0.4559*SWIR2)
         )

```

```{r}
# how much variation is there between years?

#Now calculate FLATS, TC Wetness, as well as the NDWI and Phenology indices used to create FLATS
test<-nests_all_bands_clear%>%
  mutate(year=year(ymd(Date)))%>%
  group_by(nest_id,year)%>%
  summarise(across(c(Blue:SWIR2,water,NDWI:TCWet),list(mean=mean,max=max,min=min,var=var)))%>%
  ungroup()%>%
  group_by(nest_id)%>%
  mutate(across(-year,function(x) (x-mean(x,na.rm=T))/sd(x,na.rm=T)))%>%
  ungroup()%>%
  group_by(year)%>%
  summarize(everything(),list(mean=mean,max=max,min=min))


```

# Define nest fate responses at each nest location

First, gather information about nest fates at each nest location. The SHARP nest fate protocol defines criteria for classifying categorical nest fates, the factor that determined the "completion" of the nest, and quantitative fates, information about the factors that determined the fates of each individual in the nest (Elphick and Field, 2013). Since our spectral hypotheses focus on flood severity at a nest location, we will select nests that were categorized as successful at fledging at least one young or failed due to flooding, i.e., experienced a flooding event resulting in all remaining individuals in the nest to be lost, to remove noise from any other processes influencing reproductive success such as predation.

Including other nest fates such as depredation to distinguish all nest locations that experienced reproductive failure or all locations without flooding failure may introduce noise into relationships focused on flood risk. For instance, it is possible nests that were predated were simply lost before they could experience a fatal flood event, so considering them free of flood risk would be inaccurate. It is also inaccurate to consider all predated and flooded nests with equal flood risk. 

From the successful and flood-failed nests, we will consider two nest fate responses. The categorical nest fate, success or failure due to flooding, will be used to distinguish the probability of flood-failure and quantitative nest fate, proportion of individuals in the nest lost to flooding, will be used to distinguish the severity of this flood risk to nesting success (a continuous measure of fitness loss due to flooding).
```{r}
nest_locations<-read.csv(paste0(inDir,"Nests/nest_locations_01_3_23.csv"))%>%
  rename(nest_id=id,site=Site,year=Year)%>%
  # Add nest identifying columns
  #add site names
  mutate(site=substr(nest_id,start=1,stop=2),
         #add nest number
         nest_num=as.numeric(substr(nest_id,(nchar(nest_id)-2),nchar(nest_id))))

fates<-read.csv(paste0(inDir,"Nests/NestFates_2001-2020.csv"),na.strings=c("","NOT REC","NA"))%>%
  #select and format variables
  dplyr::select("nest_id"="SHARPNestID","UltimateNestFate","FirstEggDate"="EstFirstEggDate",
                "maxeggs"="MaxNumEggs","Nsuccess"="NumFledged",
                "NumEggsFloodedInNest","NumEggsFloodedFromNest","NumEggsFloodedMissing",
                "NumChicksFlooded","NumChicksFloodedMissing",
                "NumEggsDepredated", "NumEggsDepredatedMissing","NumChicksDepredated","NumChicksDepredatedMissing")%>%
  mutate(across(c("NumEggsFloodedInNest","NumEggsFloodedFromNest","NumEggsFloodedMissing",
                  "NumChicksFlooded","NumChicksFloodedMissing","maxeggs","Nsuccess",
                  "NumEggsDepredated", "NumEggsDepredatedMissing","NumChicksDepredated","NumChicksDepredatedMissing"),
                as.numeric))%>%
  # Add nest identifying columns
  mutate(year=as.numeric(paste0("20",substr(nest_id,start=3,stop=4))),
         #add site names
         site=substr(nest_id,start=1,stop=2),
         #add nest number
         nest_num=as.numeric(substr(nest_id,(nchar(nest_id)-2),nchar(nest_id))))%>%
  # Format fate response variables
  rowwise()%>%
  # 1. proportion nestlings lost to flooding
  mutate(flooded_cont=sum(c(NumEggsFloodedInNest,NumEggsFloodedFromNest,NumEggsFloodedMissing,
                            NumChicksFlooded,NumChicksFloodedMissing),na.rm = T),
         flooded_prop=round(flooded_cont/maxeggs,2),
         # 2. Probability nest failed/was successful in general
         fate=case_when(
           UltimateNestFate%in%c("FLEDGED")~1,
           UltimateNestFate%in%c("DEPREDATED","FLOODED","FLOODED/DEPREDATED","NEVER HAD EGGS","NEVER HAD","FAIL UNKNOWN")~0,
           !(UltimateNestFate%in%c("FLEDGED","DEPREDATED","FLOODED","FLOODED/DEPREDATED",
                                   "NEVER HAD EGGS","NEVER HAD","FAIL UNKNOWN"))~NA),
         # 3. Probability nest failed due to flooding
         flooded_fate=ifelse(UltimateNestFate%in%c("FLOODED","FLOODED/DEPREDATED"),1,0))%>%
  ungroup()%>%
  select(nest_id,FirstEggDate, year, site, nest_num, flooded_prop,fate,flooded_fate,maxeggs,flooded_cont)

  #set all fate variables to NA for nests with NA for ultimate nest fate
fates[is.na(fates$fate),c(6,8)]<-NA
fates[is.nan(fates$flooded_prop),6]<-NA

nests<-left_join(nest_locations,fates,by=c("nest_id","year","site","nest_num"))%>%
  distinct(nest_id,.keep_all = T)%>%
  mutate(FirstEggDate=mdy(FirstEggDate))%>%
  filter(Species=="SALS",State=="CT",year>=2013)

#join nest fate information to nest spectral time series
nests_bands_fates<-nests_all_bands_clear%>%
  left_join(nests,by=c("nest_id","site","year"))%>%
  select(-bit_str)%>%
  mutate(img_year=year(Date),
         img_month=month(Date),
         # 1 means success, 0 means flood-failed, remove all other fates (predation)
         flooded_fate=case_when(
           flooded_fate==1~0,
           fate==1~1,
           flooded_fate!=1&fate!=1~NA),
         flooded_fate_char=ifelse(flooded_fate==1,"Successful","Flood-Failed"))%>% 
  #remove observations missing fate info or not flood related
  filter(!(is.na(flooded_fate)))%>%
  #take the average across nest SR values collected on the same date
  group_by(nest_id,site,year,Date)%>%
  summarise(across(c(Blue:SWIR2,water,NDWI:TCWet),mean,na.rm=T),
            across(c(img_year,img_month,maxeggs,flooded_cont,flooded_prop,flooded_fate,flooded_fate_char),first))%>%
  ungroup()%>%
  filter(year==img_year)
```


# Summarize Data Availability

How many nest locations have fate information relevant for flood risk? How many clear image dates do we have for each location's time series?
```{r}
#how many nests have images?
length(unique(nests_bands_fates$nest_id))
#how many cells have nests
  # read template HLS raster
cells<-terra::rast(paste0(outDir,"CTmarsh_UTM18_30mraster_template.tif"))
  # read nest locations
nest_shp<-st_read(paste0(inDir,"Nests/nest_locations_01_3_23.shp"))%>%
  rename(nest_id=id,site=site_cd,year=Year)%>%
  select(nest_id,site,year)
  #extract cell IDs with nests
    #bind returns the vector attributes as well as the raster attributes, cells returns the cell ID
cell_id<-terra::extract(cells, vect(nest_shp), cells=T,bind=T) 
cell_id<-st_as_sf(cell_id)%>%
  select(nest_id,cell,year,site)%>%
  st_drop_geometry()

nests_bands_fates<-nests_bands_fates%>%
  left_join(cell_id,by=c("nest_id","site","year"))

length(unique(nests_bands_fates$cell))


#how many dates does each nest site have images for?
date_count<-nests_bands_fates%>%
  count(nest_id)

#Filter out locations that have less than 4 images in their TS
nests_bands_fates<-nests_bands_fates%>%
  filter(nest_id%in%date_count[date_count$n>=4,]$nest_id)

#how many dates does each nest site have images for?
date_count<-nests_bands_fates%>%
  count(nest_id)

ggplot()+
  geom_histogram(data=date_count,aes(x=n))+
  theme_bw(base_size = 12)+
  labs(x="Number of Dates in Time Series",y="Number of Nest Locations (Total N = 179)")

ggsave(filename = paste0(outDir,"Figures/TS_Density_nests.jpeg"), width = 5, height=5, dpi = "retina")



# How many years have images and how many images per year?
distinct_months_years<-nests_bands_fates%>%
  group_by(nest_id,img_year,img_month)%>%
  summarize(month=first(img_month),
            month_count=n())%>%
  ungroup()%>%
  complete(img_year,month)%>%
  mutate(month_count=ifelse(is.na(month_count),0,month_count),
         date=paste(month,img_year,sep="-"),
         date=my(date),
         date=factor(format(as.Date(date),"%b-%Y"),levels=c("May-2013", "Jun-2013", "Jul-2013", "Aug-2013",
                                                               "May-2014", "Jun-2014", "Jul-2014", "Aug-2014",
                                                               "May-2015", "Jun-2015", "Jul-2015", "Aug-2015",
                                                               "May-2016", "Jun-2016", "Jul-2016", "Aug-2016",
                                                               "May-2017", "Jun-2017", "Jul-2017", "Aug-2017",
                                                               "May-2018", "Jun-2018", "Jul-2018", "Aug-2018",
                                                               "May-2019", "Jun-2019", "Jul-2019", "Aug-2019",
                                                               "May-2020", "Jun-2020", "Jul-2020", "Aug-2020")))

ggplot(distinct_months_years,aes(x=date,group=month_count))+
  geom_bar(position="stack",stat = "count",aes(fill=month_count))+
  scale_fill_distiller(palette = "Purples", direction = 1, breaks=c(0,2,4,6,8,10), labels=c("0","2","4","6","8","10"))+
  theme_bw(base_size = 12)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  labs(fill="Number of Clear Pixel Dates",x="Date",y="Number of Nest Locations (Total N= 227)")

ggsave(filename = paste0(outDir,"Figures/TS_Distribution_nests.jpeg"), width = 10, height=4, dpi = "retina")
```


# Visual Analysis

Here, we will summarize the distribution of spectral band surface reflectance and water indicator values in each nest location's time series. Flood-failed nests have been shown to experience higher average tide heights and flooding frequencies than successful nests (Bayard and Elphick), so we will calculate the mean, or baseline conditions of each time series to estimate the average flood exposure at a particular nest location. Nest flooding has also been predicted using maximum high tide and extremity of rare flooding events (Ruskin et al. 2017) so we will also summarize each time series by its maximum and minimum values to estimate the magnitude of extreme events experienced at each nest location. Minimum values should capture the highest severity flooding events based on surface reflectance, while these events are captured by the maximum values for water indicators.



## How do the distributions of mean values and variances in the time series of band surface relfectance and water indicator values at each nest location?
#--------------------------------------------------------------------------------------
```{r}
### Discrete Nest Fate Variables

# Nest-Resolution
#-------------------------------------------------------------------------
nest_avgs<-nests_bands_fates%>%
  mutate(flooded_prop=ifelse(flooded_prop>1,1,flooded_prop))%>%
  group_by(nest_id,site,year,cell)%>%
  summarise(across(c(Blue:SWIR2,water:TCWet), mean, na.rm=T),
            across(c(flooded_fate_char,flooded_fate,flooded_prop),first))
nest_sd<-nests_bands_fates%>%
  mutate(flooded_prop=ifelse(flooded_prop>1,1,flooded_prop))%>%
  group_by(nest_id,site,year,cell)%>%
  summarise(across(c(Blue:SWIR2,water:TCWet), var, na.rm=T),
            across(c(flooded_fate_char,flooded_fate,flooded_prop),first))
nest_min<-nests_bands_fates%>%
  mutate(flooded_prop=ifelse(flooded_prop>1,1,flooded_prop))%>%
  group_by(nest_id,site,year,cell)%>%
  summarise(across(c(Blue:SWIR2,water:TCWet), min, na.rm=T),
            across(c(flooded_fate_char,flooded_fate,flooded_prop),first))
nest_max<-nests_bands_fates%>%
  mutate(flooded_prop=ifelse(flooded_prop>1,1,flooded_prop))%>%
  group_by(nest_id,site,year,cell)%>%
  summarise(across(c(Blue:SWIR2,water:TCWet), max, na.rm=T),
            across(c(flooded_fate_char,flooded_fate,flooded_prop),first))

#how does the band average value vary between fates?
avg_sr<-ggplot(pivot_longer(nest_avgs,cols = c("Blue":"SWIR2"),names_to = "Band",values_to = "SR"), aes(x=SR, group=flooded_fate_char, fill=flooded_fate_char)) +
    geom_density(adjust=1.5, alpha=.4)+
    theme_classic()+
  facet_wrap(~Band, scales = "free")+
  labs(fill="Nest Fate",x="Mean of Breeding Season Time Series",y="Density of Nest Locations")
#how does the band variance vary between fates?
var_sr<-ggplot(pivot_longer(nest_sd,cols = c("Blue":"SWIR2"),names_to = "Band",values_to = "SR"), aes(x=SR,group=flooded_fate_char,fill=flooded_fate_char)) +
    geom_density(adjust=1.5, alpha=.4)+
    theme_classic()+
  facet_wrap(~Band, scales = "free")+
  labs(fill="Nest Fate",x="Variance of Breeding Season Time Series",y="Density of Nest Locations")
#how does the band minimum vary between fates?
min_sr<-ggplot(pivot_longer(nest_min,cols = c("Blue":"SWIR2"),names_to = "Band",values_to = "SR"), aes(x=SR,group=flooded_fate_char,fill=flooded_fate_char)) +
    geom_density(adjust=1.5, alpha=.4)+
    theme_classic()+
  facet_wrap(~Band, scales = "free")+
  labs(fill="Nest Fate",x="Minimum of Breeding Season Time Series",y="Density of Nest Locations")

#how does the wet index avg value vary between fates
avg_wi<-ggplot(pivot_longer(nest_avgs,cols = c("water","NDWI","FLATS","TCWet"),names_to = "Index",values_to = "Value"), aes(x=Value,group=flooded_fate_char,fill=flooded_fate_char)) +
    geom_density(adjust=1.5, alpha=.4)+
    theme_classic()+
  facet_wrap(~Index, scales = "free")+
  labs(fill="Nest Fate",x="Mean of Breeding Season Time Series",y="Density of Nest Locations")
#how does the wet index variance vary between fates
var_wi<-ggplot(pivot_longer(nest_sd,cols = c("water","NDWI","FLATS","TCWet"),names_to = "Index",values_to = "Value"), aes(x=Value,group=flooded_fate_char,fill=flooded_fate_char)) +
    geom_density(adjust=1.5, alpha=.4)+
    theme_classic()+
  facet_wrap(~Index, scales = "free")+
  labs(fill="Nest Fate",x="Variance of Breeding Season Time Series",y="Density of Nest Locations")
#how does the wet index max vary between fates
max_wi<-ggplot(pivot_longer(nest_max,cols = c("water","NDWI","FLATS","TCWet"),names_to = "Index",values_to = "Value"), aes(x=Value,group=flooded_fate_char,fill=flooded_fate_char)) +
    geom_density(adjust=1.5, alpha=.4)+
    theme_classic()+
  facet_wrap(~Index, scales = "free")+
  labs(fill="Nest Fate",x="Maximum of Breeding Season Time Series",y="Density of Nest Locations")

#write all plots to file
#((p1+p2+plot_layout(axis_titles="collect"))/(p3+p4+plot_layout(axis_titles="collect")))+plot_layout(guides = "collect")
#ggsave(filename = paste0(outDir,"Figures/FloodedFate_Mean_Var_Distrib.jpeg"), width = 12, height=7, dpi = "retina")

#write individual plots to file
avg_sr
ggsave(filename = paste0(outDir,"Figures/Nest_SR_Mean_Distrib.jpeg"), width = 8, height=5, dpi = "retina")
var_sr
ggsave(filename = paste0(outDir,"Figures/Nest_SR_Var_Distrib.jpeg"), width = 9, height=5, dpi = "retina")
min_sr
ggsave(filename = paste0(outDir,"Figures/Nest_SR_Min_Distrib.jpeg"), width = 8, height=5, dpi = "retina")
avg_wi
ggsave(filename = paste0(outDir,"Figures/Nest_WI_Mean_Distrib.jpeg"), width = 8, height=5, dpi = "retina")
var_wi
ggsave(filename = paste0(outDir,"Figures/Nest_WI_Var_Distrib.jpeg"), width = 9, height=5, dpi = "retina")
max_wi
ggsave(filename = paste0(outDir,"Figures/Nest_WI_Max_Distrib.jpeg"), width = 8, height=5, dpi = "retina")


```


```{r}
#### Continuous Nest Fate Variables

# nest resolution
#----------------------------------------------------------------------------------------
avg_sr_c<-ggplot(pivot_longer(nest_avgs,cols = c("Blue":"SWIR2"),names_to = "Band",values_to = "SR"),aes(x=flooded_prop,y=SR))+#flooded_fate
  geom_point()+
  geom_smooth(method = "glm", se = T)+
  theme_classic()+
  facet_wrap(~Band, scales = "free")+
  labs(y="Mean of Breeding Season Time Series",x="Proportion Nest Contents Flooded")
var_sr_c<-ggplot(pivot_longer(nest_sd,cols = c("Blue":"SWIR2"),names_to = "Band",values_to = "SR"),aes(x=flooded_prop,y=SR))+#flooded_fate
  geom_point()+
  geom_smooth(method = "glm", se = T)+
  theme_classic()+
  facet_wrap(~Band, scales = "free")+
  labs(y="Variance of Breeding Season Time Series",x="Proportion Nest Contents Flooded")
min_sr_c<-ggplot(pivot_longer(nest_min,cols = c("Blue":"SWIR2"),names_to = "Band",values_to = "SR"),aes(x=flooded_prop,y=SR))+#flooded_fate
  geom_point()+
  geom_smooth(method = "glm", se = T)+
  theme_classic()+
  facet_wrap(~Band, scales = "free")+
  labs(y="Minimum of Breeding Season Time Series",x="Proportion Nest Contents Flooded")

avg_wi_c<-ggplot(pivot_longer(nest_avgs,cols = c("water","NDWI","FLATS","TCWet"),names_to = "Index",values_to = "Value"),aes(x=flooded_prop,y=Value))+#flooded_fate
  geom_point()+
  geom_smooth(method = "glm", se = T)+
  theme_classic()+
  facet_wrap(~Index, scales = "free")+
  labs(y="Mean of Breeding Season Time Series",x="Proportion Nest Contents Flooded")
var_wi_c<-ggplot(pivot_longer(nest_sd,cols = c("water","NDWI","FLATS","TCWet"),names_to = "Index",values_to = "Value"),aes(x=flooded_prop,y=Value))+#flooded_fate
  geom_point()+
  geom_smooth(method = "glm", se = T)+
  theme_classic()+
  facet_wrap(~Index, scales = "free")+
  labs(y="Variance of Breeding Season Time Series0",x="Proportion Nest Contents Flooded")
max_wi_c<-ggplot(pivot_longer(nest_max,cols = c("water","NDWI","FLATS","TCWet"),names_to = "Index",values_to = "Value"),aes(x=flooded_prop,y=Value))+#flooded_fate
  geom_point()+
  geom_smooth(method = "glm", se = T)+
  theme_classic()+
  facet_wrap(~Index, scales = "free")+
  labs(y="Maximum of Breeding Season Time Series",x="Proportion Nest Contents Flooded")

#write all plots to file
#((s2+s1+plot_layout(axis_titles = "collect"))/(s4+s3+plot_layout(axis_titles = "collect")))
#ggsave(filename = paste0(outDir,"Figures/NestPropFlood_Mean_Var_Distrib.jpeg"), width = 12, height=7, dpi = "retina")

#write individual plots to file
avg_sr_c
ggsave(filename = paste0(outDir,"Figures/Nest_SR_Mean_scatter.jpeg"), width = 8, height=5, dpi = "retina")
var_sr_c
ggsave(filename = paste0(outDir,"Figures/Nest_SR_Var_scatter.jpeg"), width = 9, height=5, dpi = "retina")
min_sr_c
ggsave(filename = paste0(outDir,"Figures/Nest_SR_Min_scatter.jpeg"), width = 8, height=5, dpi = "retina")
avg_wi_c
ggsave(filename = paste0(outDir,"Figures/Nest_WI_Mean_scatter.jpeg"), width = 8, height=5, dpi = "retina")
var_wi_c
ggsave(filename = paste0(outDir,"Figures/Nest_WI_Var_scatter.jpeg"), width = 9, height=5, dpi = "retina")
max_wi_c
ggsave(filename = paste0(outDir,"Figures/Nest_WI_Max_scatter.jpeg"), width = 8, height=5, dpi = "retina")
```



## visualize time series for each band and water index for successful and unsuccessful nests
#---------------------------------------------------------------------------------------------------
```{r}
# Nest resolution
success<-nests_bands_fates%>%
  filter(flooded_fate==1)%>%
  group_by(Date,nest_id)%>%
  summarise_at(vars(Blue:TCWet), mean, na.rm=T)%>%
  pivot_longer(cols = c("Blue":"TCWet"),names_to = "Band",values_to = "SR")%>%
  mutate(doy=yday(Date))
failed<-nests_bands_fates%>%
  filter(flooded_fate==0)%>%
  group_by(Date,nest_id)%>%
  summarise_at(vars(Blue:TCWet), mean, na.rm=T)%>%
  pivot_longer(cols = c("Blue":"TCWet"),names_to = "Band",values_to = "SR")%>%
  mutate(doy=yday(Date))


ts1<-ggplot()+
  geom_line(data=failed%>%filter(Band%in%c("water","TCWet","NDWI","FLATS")), aes(x=doy,y=SR,group=nest_id,color="Flood-Failed"))+
  geom_line(data=success%>%filter(Band%in%c("water","TCWet","NDWI","FLATS")),aes(x=doy,y=SR,group=nest_id,color="Successful"))+
  theme_bw(base_size = 12)+
  labs(x="Day of Year",y="Index Value",color="Nest Fate")+
  facet_wrap(~Band)
ts2<-ggplot()+
  geom_line(data=failed%>%filter(Band%in%c("Red","Green","Blue","NIR","SWIR1","SWIR2")), aes(x=doy,y=SR,group=nest_id,color="Flood-Failed"))+
  geom_line(data=success%>%filter(Band%in%c("Red","Green","Blue","NIR","SWIR1","SWIR2")),aes(x=doy,y=SR,group=nest_id,color="Successful"))+
  theme_bw(base_size = 12)+
  labs(x="Day of Year",y="Surface Reflectance",color="Nest Fate")+
  facet_wrap(~Band)

ts1+ts2+plot_layout(guides="collect",axis_titles = "collect")
ggsave(filename = paste0(outDir,"Figures/NestFloodFailed_TS.jpeg"), width = 12, height=5, dpi = "retina")

ts1
ggsave(filename = paste0(outDir,"Figures/Nests_WI_TS.jpeg"), width = 8, height=5, dpi = "retina")

ts2
ggsave(filename = paste0(outDir,"Figures/Nests_SR_TS.jpeg"), width = 8, height=5, dpi = "retina")

ggplot()+
  geom_line(data=failed%>%filter(Band%in%c("water")&nest_id=="HM15SALS508"), aes(x=month,y=SR,group=nest_id,color="Flood-Failed"))
```



## Visualize spectral distributions between successful and unsuccessful nests
#-------------------------------------------------------------------------------------------
```{r}
upper.95.ci<-function(col){
  mean(col,na.rm=T)+(1.96*(sd(col,na.rm=T)/(sqrt(length(col)))))
}
lower.95.ci<-function(col){
  mean(col,na.rm=T)-(1.96*(sd(col,na.rm=T)/(sqrt(length(col)))))
}
mean.narm<-function(col){
  mean(col,na.rm=T)
}

#Nest resolution

#No noticeable difference in spectral distribution of successful/unsuccessful nests
success_band_sum<-nests_bands_fates%>%
  group_by(flooded_fate_char)%>%
  summarise(across(Blue:SWIR2, list(mean=mean,uc= upper.95.ci, lc=lower.95.ci)))%>%
  ungroup()%>%
  pivot_longer(cols = 2:ncol(.),names_to = c("Band","Stat"),names_sep = "_",values_to = "Value")%>%
  pivot_wider(names_from = "Stat",values_from = "Value")%>%
  mutate(Band=factor(Band,levels=c("Blue","Green","Red","NIR","SWIR1","SWIR2")))

sd1<-ggplot(data=success_band_sum,aes(x=Band,y=mean,group=flooded_fate_char))+
  geom_ribbon(aes(ymin=lc,ymax=uc,fill=flooded_fate_char),alpha=0.3)+
  geom_line(aes(color=flooded_fate_char))+
  theme_bw(base_size=12)+
  labs(x="Spectral Band (Wavelength)",y="Average Surface Refectance 2013-2020",fill="Nest Fate",color="Nest Fate")

# Slightly lower reflectance in the SWIR bands for flood-failed nests.
flood_band_sum<-nests_bands_fates%>%
  group_by(flooded_fate_char)%>%
  summarise(across(Blue:SWIR2, list(mean=mean,uc= upper.95.ci, lc=lower.95.ci)))%>%
  ungroup()%>%
  pivot_longer(cols = 2:ncol(.),names_to = c("Band","Stat"),names_sep = "_",values_to = "Value")%>%
  pivot_wider(names_from = "Stat",values_from = "Value")%>%
  mutate(Band=factor(Band,levels=c("Blue","Green","Red","NIR","SWIR1","SWIR2")))

sd2<-ggplot(data=flood_band_sum,aes(x=Band,y=mean,group=flooded_fate_char))+
  geom_ribbon(aes(ymin=lc,ymax=uc,fill=flooded_fate_char),alpha=0.3)+
  geom_line(aes(color=flooded_fate_char))+
  theme_bw(base_size=12)+
  labs(x="Spectral Band (Wavelength)",y="Average Surface Refectance 2013-2020",fill="Nest Fate",color="Nest Fate")

sd1+sd2+plot_layout(axis_titles = "collect")
sd1
ggsave(filename = paste0(outDir,"Figures/FloodedNest_Spectral_Distributions.jpeg"), width = 7, height=4, dpi = "retina")
```



# Statistical Analysis
```{r}
#library(lme4)
library(glmmTMB)
library(car)
#library(bbmle)
library(DHARMa)
library(broom.mixed)
library(ggstats)

# format the data for stats analyses
nest_modeling<-nests_bands_fates%>%
  filter(flooded_prop<=1)%>%
  group_by(nest_id)%>%
  summarise(across(c(Blue:SWIR2,water,NDWI:TCWet), list(mean=mean, var=var, min=min, max=max)),
            across(c(flooded_prop,flooded_fate,flooded_cont,maxeggs,site,cell,year), first))%>%
  ungroup()%>%
  mutate(cell_year=paste(cell,year,sep="."))

#write.csv(nest_modeling,paste0(outDir,"CT_nests_flood_index.csv"),row.names=F)
```

## Test for statistically significant differences between mean and variance in SR time series for binary nest responses.

Since nest locations are not independent, they share values from the pixel they fall within, we need to account for this pseudo replication. The pixel itself is an observation and nest information needs to be summarized within it.
```{r}
#summarize at the pixel level to address replicates
cell_modeling<-nest_modeling%>%
  group_by(cell)%>%
  summarise(across(c(Blue_mean:TCWet_max), mean),
            n_success=sum(flooded_fate),
            n=n(),
            flooded_fate=case_when(
              n_success==n~1,
              n_success==0~0,
              n_success!=0&n_success!=n~NA))%>%
  ungroup()%>%
  filter(!is.na(flooded_fate))%>%
  select(-water_min)

# Are the variances between successful/unsuccessful nests sig different?
  # compare whether the mean variance of successful nests is lower than mean variance of unsuccessful/flooded nests
results_list1<-list()
comparison_list<-c("mean","var","max","min")



for(j in 1:length(comparison_list)){
n_results<-length(cell_modeling%>%select(ends_with(comparison_list[j])))  
results1<-data.frame(Variable=rep(NA,n_results),Type=rep(NA,n_results),Difference=rep(NA,n_results), p.Value=rep(NA,n_results))
  # use a two sample t-test because our treatment (success/not success) is independent across samples (you cant have both at one nest)
    #check if normally distributed
      #if any > than 0.05, normal. If any not normal, apply levenes test of equal variance.
if(any(unlist(apply(cell_modeling%>%select(ends_with(comparison_list[j])), 2, function(x) shapiro.test(x)$p.value))<0.05)){
        # levenes test p value less than 0.05 means the variances are different. > means they're equal
equal.nest.fate<-all(unlist(apply(cell_modeling%>%select(ends_with(comparison_list[j])),2,function(x) car::leveneTest(x~as.factor(flooded_fate),data=cell_modeling)[1,3]>0.05)))
}else{
  print("ADD var.test")
}

    #use standard t-test if they have the same variance/mean (set var.equal=T), welch's t-test, if different, is the default
if(equal.nest.fate==T){
      # collect the differences in mean between successful and failed nests (failed-success, so expect neg if success is larger and pos if flooded is lower)
results1$Difference <-unlist(apply(cell_modeling%>%select(ends_with(comparison_list[j])),2,function(x) diff(t.test(x ~ as.factor(flooded_fate),data=cell_modeling,var.equal=T)[["estimate"]])))
      # collect the p value of the difference
results1$p.Value <-unlist(apply(cell_modeling%>%select(ends_with(comparison_list[j])),2,function(x) t.test(x ~ as.factor(flooded_fate),data=cell_modeling,var.equal=T)[["p.value"]]))
      # add variable names
results1$Variable <-names(unlist(apply(cell_modeling%>%select(ends_with(comparison_list[j])),2,function(x) t.test(x ~ as.factor(flooded_fate),data=cell_modeling,var.equal=T)[["p.value"]])))
      # add add comparison type
results1$Type<-rep(comparison_list[j],n_results)
      #add results to list
results_list1[[j]]<-results1

}else{
results1$Difference <-unlist(apply(cell_modeling%>%select(ends_with(comparison_list[j])),2,function(x) diff(t.test(x ~ as.factor(flooded_fate),data=cell_modeling)[["estimate"]])))
      # collect the p value of the difference
results1$p.Value <-unlist(apply(cell_modeling%>%select(ends_with(comparison_list[j])),2,function(x) t.test(x ~ as.factor(flooded_fate),data=cell_modeling)[["p.value"]]))
      # add variable names
results1$Variable <-names(unlist(apply(cell_modeling%>%select(ends_with(comparison_list[j])),2,function(x) t.test(x ~ as.factor(flooded_fate),data=cell_modeling)[["p.value"]])))
      # add add comparison type
results1$Type<-rep(comparison_list[j],n_results)
      #add results to list
results_list1[[j]]<-results1
}

}

all_results1<-do.call('rbind',results_list1)
all_results1[,c(3:4)]<-round(all_results1[,c(3:4)],4)

write.csv(all_results1,paste0(outDir,"categorical_differences_statistics.csv"),row.names=F)
```


## Test for statistically significant relationships between mean and variance in SR time series and continuous nest responses

We will use generalized linear mixed-effects models to account for pseudo-replication within HLS pixels. Multiple nests that fall within the same pixel get assigned the same value at at pixel. Each nest is in essence a replicate sample of each pixel, causing spectral time series to be spatially correlated. Accounting for pixel ID as a random effect can account for this non-independence.
```{r}
# look at correlation among variables- all correlated, run separate
all_terms<-c("Green_mean","Blue_mean","Red_mean","NIR_mean","SWIR1_mean","SWIR2_mean",
             "Green_var","Blue_var","Red_var","NIR_var","SWIR1_var","SWIR2_var")
cor(nest_modeling[,all_terms])

## Analysis Functions
#---------------------------------------------------------------
# Check for over dispersion
ODFunc<-function(x){
  chisq<-sum((resid(x, type='pearson')^2)) 
  chisq/df.residual(x)
  ##significantly greater than 1? 
  out<-1-pchisq(chisq, df.residual(x))
  print(out);print(ifelse(out<=0.05, "significant","Not significant"))
}

## Test different error distribution fits
#---------------------------------------------------------------------------
# 1 . start with a simple glmm without flood metrics
####
#nest model overdispersed. Negbinomial better fit.
mod<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year), data=nest_modeling, family=binomial(link="logit"))
mod<-glmmTMB(flooded_fate ~ (1|cell_year), data=nest_modeling, family=binomial(link="logit"))



  # look at diagnostic plots to see if they meet assumptions of non-dependence etc
bmod_simres <- simulateResiduals(mod)
plot(bmod_simres)

  #over dispersed?
ODFunc(mod)



# 2. try a distribution that accounts for overdispersion - betabinomial, lognormal
####
od.mod<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell), data=nest_modeling, family=betabinomial(link="logit"))
  

  #diagnostic plots with simulated residuals
bbmod_simres <- simulateResiduals(od.mod)
plot(bbmod_simres)
  #look pretty good
```

```{r}
#Fit models
# categorical fate (success or flood-failed)
cat.rm<-glmmTMB(flooded_fate ~ (1|cell_year)+Red_mean, data=nest_modeling, family=binomial(link="logit"))
cat.rv<-glmmTMB(flooded_fate ~ (1|cell_year)+Red_var, data=nest_modeling, family=binomial(link="logit"))
cat.rmin<-glmmTMB(flooded_fate ~ (1|cell_year)+Red_min, data=nest_modeling, family=binomial(link="logit"))
cat.gm<-glmmTMB(flooded_fate ~ (1|cell_year)+Green_mean, data=nest_modeling, family=binomial(link="logit"))
cat.gv<-glmmTMB(flooded_fate ~ (1|cell_year)+Green_var, data=nest_modeling, family=binomial(link="logit"))
cat.gmin<-glmmTMB(flooded_fate ~ (1|cell_year)+Green_min, data=nest_modeling, family=binomial(link="logit"))
cat.bm<-glmmTMB(flooded_fate ~ (1|cell_year)+Blue_mean, data=nest_modeling, family=binomial(link="logit"))
cat.bv<-glmmTMB(flooded_fate ~ (1|cell_year)+Blue_var, data=nest_modeling, family=binomial(link="logit"))
cat.bmin<-glmmTMB(flooded_fate ~ (1|cell_year)+Blue_min, data=nest_modeling, family=binomial(link="logit"))
cat.nm<-glmmTMB(flooded_fate ~ (1|cell_year)+NIR_mean, data=nest_modeling, family=binomial(link="logit"))
cat.nv<-glmmTMB(flooded_fate ~ (1|cell_year)+NIR_var, data=nest_modeling, family=binomial(link="logit"))
cat.nmin<-glmmTMB(flooded_fate ~ (1|cell_year)+NIR_min, data=nest_modeling, family=binomial(link="logit"))
cat.s1m<-glmmTMB(flooded_fate ~ (1|cell_year)+SWIR1_mean, data=nest_modeling, family=binomial(link="logit"))
cat.s1v<-glmmTMB(flooded_fate ~ (1|cell_year)+SWIR1_var, data=nest_modeling, family=binomial(link="logit"))
cat.s1min<-glmmTMB(flooded_fate ~ (1|cell_year)+SWIR1_min, data=nest_modeling, family=binomial(link="logit"))
cat.s2m<-glmmTMB(flooded_fate ~ (1|cell_year)+SWIR2_mean, data=nest_modeling, family=binomial(link="logit"))
cat.s2v<-glmmTMB(flooded_fate ~ (1|cell_year)+SWIR2_var, data=nest_modeling, family=binomial(link="logit"))
cat.s2min<-glmmTMB(flooded_fate ~ (1|cell_year)+SWIR2_min, data=nest_modeling, family=binomial(link="logit"))
cat.flatsm<-glmmTMB(flooded_fate ~ (1|cell_year)+FLATS_mean, data=nest_modeling, family=binomial(link="logit"))
cat.flatsv<-glmmTMB(flooded_fate ~ (1|cell_year)+FLATS_var, data=nest_modeling, family=binomial(link="logit"))
cat.flatsmax<-glmmTMB(flooded_fate ~ (1|cell_year)+FLATS_max, data=nest_modeling, family=binomial(link="logit"))
cat.tcm<-glmmTMB(flooded_fate ~ (1|cell_year)+TCWet_mean, data=nest_modeling, family=binomial(link="logit"))
cat.tcv<-glmmTMB(flooded_fate ~ (1|cell_year)+TCWet_var, data=nest_modeling, family=binomial(link="logit"))
cat.tcmax<-glmmTMB(flooded_fate ~ (1|cell_year)+TCWet_max, data=nest_modeling, family=binomial(link="logit"))
cat.waterm<-glmmTMB(flooded_fate ~ (1|cell_year)+water_mean, data=nest_modeling, family=binomial(link="logit"))
cat.waterv<-glmmTMB(flooded_fate ~ (1|cell_year)+water_var, data=nest_modeling, family=binomial(link="logit"))
cat.watermax<-glmmTMB(flooded_fate ~ (1|cell_year)+water_max, data=nest_modeling, family=binomial(link="logit"))
cat.ndwim<-glmmTMB(flooded_fate ~ (1|cell_year)+NDWI_mean, data=nest_modeling, family=binomial(link="logit"))
cat.ndwiv<-glmmTMB(flooded_fate ~ (1|cell_year)+NDWI_var, data=nest_modeling, family=binomial(link="logit"))
cat.ndwimax<-glmmTMB(flooded_fate ~ (1|cell_year)+NDWI_max, data=nest_modeling, family=binomial(link="logit"))

# quantitative fate (proportion nest contents lost to flooding)
prop.rm<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+Red_mean, data=nest_modeling, family=binomial(link="logit"))
prop.rv<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+Red_var, data=nest_modeling, family=binomial(link="logit"))
prop.rmin<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+Red_min, data=nest_modeling, family=binomial(link="logit"))
prop.gm<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+Green_mean, data=nest_modeling, family=binomial(link="logit"))
prop.gv<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+Green_var, data=nest_modeling, family=binomial(link="logit"))
prop.gmin<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+Green_min, data=nest_modeling, family=binomial(link="logit"))
prop.bm<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+Blue_mean, data=nest_modeling, family=binomial(link="logit"))
prop.bv<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+Blue_var, data=nest_modeling, family=binomial(link="logit"))
prop.bmin<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+Blue_min, data=nest_modeling, family=binomial(link="logit"))
prop.nm<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+NIR_mean, data=nest_modeling, family=binomial(link="logit"))
prop.nv<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+NIR_var, data=nest_modeling, family=binomial(link="logit"))
prop.nmin<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+NIR_min, data=nest_modeling, family=binomial(link="logit"))
prop.s1m<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+SWIR1_mean, data=nest_modeling, family=binomial(link="logit"))
prop.s1v<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+SWIR1_var, data=nest_modeling, family=binomial(link="logit"))
prop.s1min<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+SWIR1_min, data=nest_modeling, family=binomial(link="logit"))
prop.s2m<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+SWIR2_mean, data=nest_modeling, family=binomial(link="logit"))
prop.s2v<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+SWIR2_var, data=nest_modeling, family=binomial(link="logit"))
prop.s2min<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+SWIR2_min, data=nest_modeling, family=binomial(link="logit"))
prop.flatsm<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+FLATS_mean, data=nest_modeling, family=binomial(link="logit"))
prop.flatsv<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+FLATS_var, data=nest_modeling, family=binomial(link="logit"))
prop.flatsmax<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+FLATS_max, data=nest_modeling, family=binomial(link="logit"))
prop.tcm<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+TCWet_mean, data=nest_modeling, family=binomial(link="logit"))
prop.tcv<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+TCWet_var, data=nest_modeling, family=binomial(link="logit"))
prop.tcmax<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+TCWet_max, data=nest_modeling, family=binomial(link="logit"))
prop.waterm<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+water_mean, data=nest_modeling, family=binomial(link="logit"))
prop.waterv<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+water_var, data=nest_modeling, family=binomial(link="logit"))
prop.watermax<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+water_max, data=nest_modeling, family=binomial(link="logit"))
prop.ndwim<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+NDWI_mean, data=nest_modeling, family=binomial(link="logit"))
prop.ndwiv<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+NDWI_var, data=nest_modeling, family=binomial(link="logit"))
prop.ndwimax<-glmmTMB(cbind(flooded_cont,maxeggs-flooded_cont) ~ (1|cell_year)+NDWI_max, data=nest_modeling, family=binomial(link="logit"))

#list to contain all the models
cat_list<-list(cat.bm,cat.bv,cat.bmin,cat.gm,cat.gv,cat.gmin,cat.rm,cat.rv,cat.rmin,cat.nm,cat.nv,cat.nmin,cat.s1m,cat.s1v,cat.s1min,cat.s2m,cat.s2v,cat.s2min,cat.flatsm,cat.flatsv,cat.flatsmax,cat.waterm,cat.waterv,cat.watermax,cat.ndwim,cat.ndwiv,cat.ndwimax,cat.tcm,cat.tcv,cat.tcmax)
prop_list<-list(prop.bm,prop.bv,prop.bmin,prop.gm,prop.gv,prop.gmin,prop.rm,prop.rv,prop.rmin,prop.nm,prop.nv,prop.nmin,prop.s1m,prop.s1v,prop.s1min,prop.s2m,prop.s2v,prop.s2min,prop.flatsm,prop.flatsv,prop.flatsmax,prop.waterm,prop.waterv,prop.watermax,prop.ndwim,prop.ndwiv,prop.ndwimax,prop.tcm,prop.tcv,prop.tcmax)

#add all the model lists to a list
mod_list<-list(cat_list,prop_list)
#name the response in the same order
response_list<-c("Success.FloodFail","Proportion.Nest.Contents.Flooded")
```

## Model Inference
#---------------------------------------------------------------------
```{r}
results_list<-list()

#for each response variable model list...
for(j in 1:length(mod_list)){

mods<-mod_list[[j]]

results<-data.frame(Response=NA,Variable=NA, Odds.Ratio=NA, Conf.High=NA, Conf.Low=NA, Change.In.Response=NA,p.Value=NA,LRT=NA)

for(i in 1:length(mods)){
#format the coefficients and confidence intervals
coef.temp <- broom.mixed::tidy(mods[[i]], conf.int = TRUE)

results[i,]$Response<-response_list[j]
results[i,]$Variable<-coef.temp[2,]$term
#Odds ratio is the percent change in the original odds of the response. 1.05=5% increase in the odds (success/fails).
results[i,]$Odds.Ratio<-exp(coef.temp[2,]$estimate)
results[i,]$Conf.High<-exp(coef.temp[2,]$conf.high)
results[i,]$Conf.Low<-exp(coef.temp[2,]$conf.low)
#subtract the response (y) when x=0 from the response when x=1. Positive means increase, negative means decreasing impact.
results[i,]$Change.In.Response<-plogis(coef.temp[1,]$estimate+coef.temp[2,]$estimate)-plogis(coef.temp[1,]$estimate)
results[i,]$p.Value<-coef.temp[2,]$p.value
# ANOVA- is the residual deviance significantly improved by adding the spectral variable?
results[i,]$LRT<-car::Anova(mods[[i]],type="II")[,3] #returns the p value of chi squared statistic
}

results$Variable<-factor(results$Variable, levels=c('Blue_mean', 'Green_mean', 'Red_mean', 'NIR_mean', 'SWIR1_mean',
                                      'SWIR2_mean','FLATS_mean','NDWI_mean','TCWet_mean','water_mean',
                                      'Blue_min', 'Green_min', 'Red_min', 'NIR_min', 'SWIR1_min',
                                      'SWIR2_min','FLATS_max','NDWI_max','TCWet_max','water_max',
                                      'Blue_var', 'Green_var', 'Red_var', 'NIR_var', 'SWIR1_var',
                                      'SWIR2_var','FLATS_var','NDWI_var','TCWet_var','water_var'))
results_list[[j]]<-results
}

all_results<-do.call('rbind',results_list)
  #make inf and super big values cap at 1000
all_results<-all_results%>%
  mutate(Odds.Ratio=ifelse(Odds.Ratio>10000|Odds.Ratio=="Inf",10000,Odds.Ratio),
         Conf.High=ifelse(Conf.High>10000|Conf.High=="Inf",10000,Conf.High))
  # round everything
all_results[,-c(1:2)]<-round(all_results[,-c(1:2)],4)
#lower SWIR2 variance in pixels with a higher proportion of successful nests (pval=0.09, odds ratio ~0, Chisq from ANOVA 0.055), higher variance and mean in CFMask water classification in pixels with a higher mean proportion of nest contents flooded (pval=0.003, odds ratios greater than 1000(lower ci 457 for mean, 619 for variance), Chisq from ANOVA 0.003)
write.csv(all_results,paste0(outDir,"nest_response_band_relationship_statistics.csv"),row.names=F)

```